PARSER_BEGIN(Parser)

import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import com.monke.values.*;
import com.monke.ast.*;

public class Parser{
    public Parser(){}
}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
| "\n"
}

TOKEN :
{
  <FUN: "fn">
  |
  <COMMA: ",">
  |
  <WHILE: "while">
  |
  <IF: "if">
  |
  < BOOLEAN: ( "true" | "false") >
  |
  <VAR: "var">
  |
  <CONST: "const">
  |
  <NEW:"new">
  |
  <ASSIGN: ":=">
  |
  <REF : "!">
  |
  <PRINTLN: "println">
  |
  < ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
  |
  < NUM: (["0"-"9"]) + >
  |
  <LOGICALEQUAL: "==">
  |
  <LOWER: "<">
  |
  <LOWEROREQUAL: "<=">
  |
  <OR:"||">
  |
  <AND:"&&">
  |
  <NOT: "~">
  |
  <GREATER: ">">
  |
  <GREATEROREQUAL: ">=">
  |
  < PLUS : "+" >
  |
  < INC : "++" >
  |
  < MINUS : "-">
  |
  < DEC : "--">
  |
  < TIMES : "*">
  |
  < DIV : "/">
  |
  < LPAR : "(" >
  |
  < RPAR : ")" >
  |
  < LBRA : "{" >
  |
  < RBRA : "}" >
  |
  < EQUAL: "=" >
  |
  < SEMCOL: ";" >
  |
  < FINAL: ";;">
  |
  <STRING: "\""( ["a"-"z","A"-"Z","0"-"9"," ",".","!","?","@","#","$","%","^","&","*","(",")","-","_","+","="])+  "\"" >
}

ASTNode Start():
{ ASTNode t; }
{
   t = S() <FINAL>
   { return t; }
}

ASTNode S():
{ ASTNode t1, t2; }
{
   (
        <LBRA> t1 = SS() <RBRA> { t1 = new ASTEnv(t1); }
      |
        t1 = SS()
      )
      { return t1; }
}

ASTNode SS():
{ ASTNode t1, t2; }
{
   t1 = SE() (<SEMCOL> t2 = SE() {
       t1 = new ASTSemCol(t1, t2);
   })*
   { return t1; }
}

ASTNode SE():
{ Token op, n;
  ASTNode t1, t2; }
{
    (
      LOOKAHEAD(2) n = <ID> <ASSIGN> t2=BA() {
          t1 = new ASTAssign(new ASTId(n.image), t2);
      }
    |
      LOOKAHEAD(3) (op = <VAR> | op = <CONST>) n = <ID> <ASSIGN> t2=BA() {
           t1 = new ASTCreate(op.image, new ASTId(n.image), t2);
       }
    |
      n = <ID> {
          t1 = new ASTId(n.image);
      }
    |
      t1 = BA()
    )
    { return t1; }
}


ASTNode BA():
{
    Token op;
    ASTNode t1, t2;
}
{
t1=BM()  (LOOKAHEAD(2) op=<OR> t2=BM() {
    			t1 = new ASTOr(t1,t2);
    			})*
  { return t1;}
}

ASTNode BM():
{
    Token op;
    ASTNode t1, t2;
}
{
t1=Relop() ( LOOKAHEAD(2) op=<AND> t2=Relop() {
    			t1 = new ASTAnd(t1,t2);
    			})*
  { return t1;}
}

ASTNode Relop():
{
    Token op;
    ASTNode t1, t2;
}
{
t1=Exp() ( LOOKAHEAD(2) (op=<GREATER> | op=<LOWER> | op=<LOWEROREQUAL> | op=<GREATEROREQUAL> | op=<LOGICALEQUAL>) t2=Exp() {
    			switch (op.kind){
                    case GREATER:
                        t1 = new ASTGreater(t1,t2);
                    break;
                    case LOWER:
                        t1 = new ASTLower(t1,t2);
                    break;
                    case LOWEROREQUAL:
                        t1 = new ASTLowerOrEqual(t1,t2);
                    break;
                    case GREATEROREQUAL:
                        t1 = new ASTGreaterOrEqual(t1,t2);
                    break;
                     case LOGICALEQUAL:
                        t1 = new ASTLogicalEqual(t1,t2);
                    break;
                    default:
    			}
    			})?
  { return t1;}
}

ASTNode Exp() :
{ Token op;
  ASTNode t1, t2; }
{
   t1=Term() (
       LOOKAHEAD(1) ( op=<INC> | op=<DEC> ) {
           if (op.kind == INC){
               t1 = new ASTIncrement(t1);
           }else
               t1 = new ASTDecrement(t1);
       }
       | LOOKAHEAD(2) ( op=<PLUS> | op=<MINUS> ) t2=Term() {
           if (op.kind == PLUS)
               t1 = new ASTPlus(t1, t2);
           else
               t1 = new ASTSub(t1, t2);
       }
   )*
   { return t1; }
}



ASTNode Term() :
{Token op;
  ASTNode t1, t2;}
{
   t1=Fact() (
        LOOKAHEAD(2) ( op=<TIMES> | op=<DIV> ) t2=Term() {
    			if (op.kind == TIMES)
    				t1 = new ASTTimes(t1,t2);
                else
                	t1 = new ASTDiv(t1,t2); })*
  { return t1;}
}


ASTNode Fact() :
{ Token n,n2;
  ASTNode t, t1,t2;
  Map<String, ASTNode> l = new HashMap<String, ASTNode>();
  List<String> params = new ArrayList();
  List<ASTNode> values = new ArrayList();
}
{
   ( n=<NUM> { t = new ASTNum(Integer.parseInt(n.image));}
   | <LPAR> t=S() <RPAR>
   | n =<BOOLEAN> {t = new ASTBoolean(Boolean.parseBoolean(n.image));}
   | <PRINTLN> <LPAR> t1 = S() <RPAR> {t = new ASTPrintln(t1);}
   //| <FUN>{params.clear();} n=<Id> <LPAR> (LOOKAHEAD(2) n2=<Id>{params.add(n2.image);})? (n2=<Id>{params.add(n2.image);})?(<COMMA> n2=<Id>{params.add(n2.image);})*<RPAR> t1 = Fact(){t=new ASTFunctionEnv(n.image,new VFun(t1,params,n.image));}
   //| LOOKAHEAD(2) n = <ID> <LPAR> (t1= SE(){values.clear();values.add(t1);})? (<COMMA> t1= SE() {values.add(t1);})* <RPAR>{t = new ASTFunction(values,n.image);}
   | n =<ID> { t = new ASTId(n.image);}
   | n=<STRING> { t = new ASTString(n.image.replaceAll("\\p{P}","")); }
   | <REF> t1=Fact() { t = new ASTDeref(t1); }
   | <IF> t=SE() <LBRA> t1 = S() <RBRA> <LBRA>t2 = S() <RBRA> { t = new ASTIf(t,t1,t2); }
   | <WHILE> t1=SE() <LBRA> t2=S() <RBRA> { t = new ASTWhile(t1, t2); }
   | <MINUS> t1=Fact() { t = new ASTNeg(t1);}
   | <NOT> t1=Fact() {t = new ASTNot(t1);}
   )

   { return t; }
}





















